

## list集合去重
    方法1：效率高
    private static void removeDuplicate(List<String> list) {
        LinkedHashSet<String> set = new LinkedHashSet<String>(list.size());
        set.addAll(list);
        list.clear();
        list.addAll(set);
    }
    方法2：利用list的contains方法循环遍历；效率低
    private static void removeDuplicate(List<String> list) {
        List<String> result = new ArrayList<String>(list.size());
        for (String str : list) {
            if (!result.contains(str)) {
                result.add(str);
            }
        }
        list.clear();
        list.addAll(result);
    }

## redis hash类型集合过滤
    public void testScan(){
        Map<String,Object> param = new HashMap<String,Object>();
        param.put("key4", "d");
        param.put("key1", "a");
        param.put("key3", "c");
        param.put("key5", "e");
        param.put("key2", "b");
        opsForHash.putAll("he13", param);
        Cursor<Map.Entry<String, Object>> curosr = opsForHash.scan("he13", ScanOptions.NONE);
        while(curosr.hasNext()){
            Map.Entry<String, Object> entry = curosr.next();
            System.out.println(entry.getKey()+":"+entry.getValue());
        }
        /**
            key4:d
            key3:c
            key5:e
            key2:b
            key1:a
         */
    }


## list和数据之间的转换

    #Collections.addAll(des, src); 把src数组中的数据，添加到des集合中
    List<String> verifaces = new ArrayList<>();
    Collections.addAll(verifaces, p.getVerifaceIds());

    #list集合转化成[]
    p.setVerifaceIds(verifaces.toArray(new String[] {}));


## 静态方法中获取当前类的名称（通过匿名内部类的方法）

    protected static EgovadbOptions buildOptions(){
        String className = new Object() {
            public String getClassName() {
                String clazzName = this.getClass().getName();
                return clazzName.substring(0, clazzName.lastIndexOf('$'));
            }
        }.getClassName();
        if (className.equals("EgovadbQueryKitV3")) {
            return new EgovadbOptionsV3();
        }
        return new EgovadbOptions();
    }



## 获取图片

### 通过URL 网络获取图片，给定图片地址
    public OperateResult<String> getSnapshot() {
        OperateResult<String> or = new OperateResult<>();
        boolean isOpen = openUp();
        if (!isOpen) {
            or.error("屏幕没有开启，无法获取快照");
        }
        //返回为图片字节流
        String snapUrl = guidingUrl + Constants.GUDING_SNAPSHOT;
        try {
            URL url = new URL(snapUrl);
            HttpURLConnection conn = (HttpURLConnection) url.openConnection();
            conn.setRequestMethod("GET");
            conn.setConnectTimeout(5 * 1000);
            InputStream inStream = conn.getInputStream();// 通过输入流获取图片数据
            String picData = readInputStream(inStream);// 得到图片的二进制数据
            return or.success(picData, "获取快照接口成功");
        } catch (Exception e) {
            or.exception("获取快照接口异常", e);
        }
        return or;
    }

### springboot 直接返回字节流给前端

    @GetMapping(value = "/getPic")
    public void getSnapshotTest02(HttpServletResponse response) throws IOException {
        File file = new File("D:\\test.jpg");
        FileInputStream fis;
        fis = new FileInputStream(file);

        long size = file.length();
        byte[] temp = new byte[(int) size];
        fis.read(temp, 0, (int) size);
        fis.close();
        byte[] data = temp;
        OutputStream out = response.getOutputStream();
        response.setContentType("image/png");
        out.write(data);

        out.flush();
        out.close();
    }

    ## 从输入流中读取数据
    public static String readInputStream(InputStream inStream) throws Exception {
        ByteArrayOutputStream outStream = new ByteArrayOutputStream();
        byte[] buffer = new byte[10240];
        int len = 0;
        while ((len = inStream.read(buffer)) != -1) {
            outStream.write(buffer, 0, len);
        }
        inStream.close();
        return outStream.toString();
    }


## tomcat 下直接访问静态资源

    <Host name="localhost"  appBase="webapps" unpackWARs="true" autoDeploy="true">

        <Valve className="org.apache.catalina.valves.AccessLogValve" directory="logs"
               prefix="localhost_access_log." suffix=".txt"
               pattern="%h %l %u %t &quot;%r&quot; %s %b" />
         <!--在Host标签下加入Context标签，path指的是服务器url请求地址（例如127.0.0.1/data），docBase指的是服务器文件的路径，reloadable指的是在omcat不重启的情况下实时同步本地目录-->
         <!--个人测试 crossContext="true" 需要干掉-->
        <Context path="/data" docBase="/tmp" reloadable="true" debug="0" crossContext="true"/>
    </Host>

## vmware 中配置ubuntu 16.04 虚拟机，静态ip方法

    打开Ubuntu的终端，输入：
    sudo gedit /etc/network/interfaces  内容如下：

    auto lo
    iface lo inet loopback

    auto ens33
    iface ens33 inet static
    address 192.168.8.100
    netmask 255.255.255.0
    gateway 192.168.8.2

    配置dns
    sudo gedit /etc/resolv.conf

    nameserver 8.8.8.8

    然后，在命令行中输入：
    sudo /etc/init.d/networking restart
