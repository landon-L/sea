

## list集合去重
    方法1：效率高
    private static void removeDuplicate(List<String> list) {
        LinkedHashSet<String> set = new LinkedHashSet<String>(list.size());
        set.addAll(list);
        list.clear();
        list.addAll(set);
    }
    方法2：利用list的contains方法循环遍历；效率低
    private static void removeDuplicate(List<String> list) {
        List<String> result = new ArrayList<String>(list.size());
        for (String str : list) {
            if (!result.contains(str)) {
                result.add(str);
            }
        }
        list.clear();
        list.addAll(result);
    }

## redis hash类型集合过滤
    public void testScan(){
        Map<String,Object> param = new HashMap<String,Object>();
        param.put("key4", "d");
        param.put("key1", "a");
        param.put("key3", "c");
        param.put("key5", "e");
        param.put("key2", "b");
        opsForHash.putAll("he13", param);
        Cursor<Map.Entry<String, Object>> curosr = opsForHash.scan("he13", ScanOptions.NONE);
        while(curosr.hasNext()){
            Map.Entry<String, Object> entry = curosr.next();
            System.out.println(entry.getKey()+":"+entry.getValue());
        }
        /**
            key4:d
            key3:c
            key5:e
            key2:b
            key1:a
         */
    }


## list和数据之间的转换

    #Collections.addAll(des, src); 把src数组中的数据，添加到des集合中
    List<String> verifaces = new ArrayList<>();
    Collections.addAll(verifaces, p.getVerifaceIds());

    #list集合转化成[]
    p.setVerifaceIds(verifaces.toArray(new String[] {}));


# 静态方法中获取当前类的名称（通过匿名内部类的方法）

    protected static EgovadbOptions buildOptions(){
        String className = new Object() {
            public String getClassName() {
                String clazzName = this.getClass().getName();
                return clazzName.substring(0, clazzName.lastIndexOf('$'));
            }
        }.getClassName();
        if (className.equals("EgovadbQueryKitV3")) {
            return new EgovadbOptionsV3();
        }
        return new EgovadbOptions();
    }

# 自动化部署



# 获取图片

    ## 通过URL 网络获取图片，给定图片地址
    public OperateResult<String> getSnapshot() {
        OperateResult<String> or = new OperateResult<>();
        boolean isOpen = openUp();
        if (!isOpen) {
            or.error("屏幕没有开启，无法获取快照");
        }
        //返回为图片字节流
        String snapUrl = guidingUrl + Constants.GUDING_SNAPSHOT;
        try {
            URL url = new URL(snapUrl);
            HttpURLConnection conn = (HttpURLConnection) url.openConnection();
            conn.setRequestMethod("GET");
            conn.setConnectTimeout(5 * 1000);
            InputStream inStream = conn.getInputStream();// 通过输入流获取图片数据
            String picData = readInputStream(inStream);// 得到图片的二进制数据
            return or.success(picData, "获取快照接口成功");
        } catch (Exception e) {
            or.exception("获取快照接口异常", e);
        }
        return or;
    }

# springboot 直接返回字节流给前端

    @GetMapping(value = "/getPic")
    public void getSnapshotTest02(HttpServletResponse response) throws IOException {
        File file = new File("D:\\test.jpg");
        FileInputStream fis;
        fis = new FileInputStream(file);

        long size = file.length();
        byte[] temp = new byte[(int) size];
        fis.read(temp, 0, (int) size);
        fis.close();
        byte[] data = temp;
        OutputStream out = response.getOutputStream();
        response.setContentType("image/png");
        out.write(data);

        out.flush();
        out.close();
    }

    ## 从输入流中读取数据
    public static String readInputStream(InputStream inStream) throws Exception {
        ByteArrayOutputStream outStream = new ByteArrayOutputStream();
        byte[] buffer = new byte[10240];
        int len = 0;
        while ((len = inStream.read(buffer)) != -1) {
            outStream.write(buffer, 0, len);
        }
        inStream.close();
        return outStream.toString();
    }
